use num::{BigInt, CheckedAdd, CheckedMul, CheckedSub, Integer, One, integer::gcd};

use crate::increment;

/// All primitive Pythagorean triples generated by Euclid's formula with sides sorted in increasing order.
/// (3, 4, 5), (5, 12, 13), (8, 15, 17)...
pub struct PythagoreanTriples<T> {
    m: T,
    n: T,
}

impl<T: CheckedAdd + CheckedMul + CheckedSub + Clone + Integer> PythagoreanTriples<T> {
    pub fn new() -> Self {
        Self {
            m: T::one() + T::one(),
            n: T::one(),
        }
    }
}

impl PythagoreanTriples<BigInt> {
    pub fn new_big() -> Self {
        Self {
            m: BigInt::one() + BigInt::one(),
            n: BigInt::one(),
        }
    }
}

impl<T: CheckedAdd + CheckedMul + CheckedSub + Clone + Integer> Iterator for PythagoreanTriples<T> {
    type Item = (T, T, T);

    fn next(&mut self) -> Option<Self::Item> {
        // Generate the sorted array
        let m2 = self.m.checked_mul(&self.m)?;
        let n2 = self.n.checked_mul(&self.n)?;
        let a = m2.checked_add(&n2)?;
        let b = self
            .m
            .checked_mul(&self.n)?
            .checked_mul(&(T::one() + T::one()))?;
        let c = m2.checked_sub(&n2)?;
        let mut arr = [a, b, c];
        arr.sort();

        // assert!(gcd(gcd(arr[0].clone(), arr[1].clone()), arr[2].clone()) == T::one());

        // Find the next pair
        // Requirements:
        // m > n > 0
        // gcd(m,n) = 0
        // one of m,n even
        loop {
            if self.m > self.n {
                increment!(self.n);
            }
            if self.m == self.n {
                increment!(self.m);
                self.n = T::one();
            }
            if gcd(self.m.clone(), self.n.clone()) == T::one()
                && (self.m.is_even() || self.n.is_even())
            {
                break;
            }
        }

        Some((arr[0].clone(), arr[1].clone(), arr[2].clone()))
    }
}

crate::print_values!(
    triples, formatter "{:?}", sep "\n";
    PythagoreanTriples::<i32>::new(), 0, 100;
);
